# Map and terrain

In this section, we will accomplish the following:

* Configure the map and initialize it in the client.
* Add terrain (tall grass and boulders) to the map.
* Prevent movement into boulders.

## Map config

At this point we have the concept of a 2D grid but there is no official "map" and there is no terrain. To do so in the ECS model we will now implement the map and initialize it in the client.

Go ahead and add the MapConfig as a singleton table in the Dubhe config (dubhe.config.ts).

```ts filename="dubhe.config.ts" {7,14} copy showLineNumbers
import { DubheConfig } from '@0xobelisk/sui-common';
export const dubheConfig = {
  name: 'monster_hunter',
  description: 'monster_hunter contract',
  data: {
    Direction: ['North', 'East', 'South', 'West'],
    TerrainType: ["None", "TallGrass", "Boulder"],
    Position: { x: 'u64', y: 'u64' },
  },
  schemas: {
    player: 'StorageMap<address, bool>',
    moveable: 'StorageMap<address, bool>',
    position: 'StorageMap<address, Position>',
    map_config: 'StorageValue<MapConfig>',
  },
  errors: {
    AlreadyRegistered: 'This address is already registered',
    CannotMove: 'This entity cannot move',
  },
} as DubheConfig;
```
## Add terrain

```sui move filename="deploy_hook.move" {3-4, 7-28} copy showLineNumbers
module monster_hunter::deploy_hook ;
use monster_hunter::schema::Schema;
use monster_hunter::terrain_type;
use monster_hunter::map_config;

public entry fun run(schema: &mut Schema, _ctx: &mut TxContext) {
    let  o = terrain_type::new_none();
    let  t = terrain_type::new_tall_grass();
    let  b = terrain_type::new_boulder();
    let terrains = vector[
        vector [o, o, o, o, o, o, t, o, o, o, o, o, o, o, o],
        vector [o, o, t, o, o, o, o, o, t, o, o, o, o, b, o],
        vector [o, t, t, t, t, o, o, o, o, o, o, o, o, o, o],
        vector [o, o, t, t, t, t, o, o, o, o, b, o, o, o, o],
        vector [o, o, o, o, t, t, o, o, o, o, o, o, o, o, o],
        vector [o, o, o, b, b, o, o, o, o, o, o, o, o, o, o],
        vector [o, t, o, o, o, b, b, o, o, o, o, t, o, o, o],
        vector [o, o, t, t, o, o, o, o, o, t, o, b, o, o, t],
        vector [o, o, t, o, o, o, o, t, t, t, o, b, b, o, o],
        vector [o, o, o, o, o, o, o, t, t, t, o, b, t, o, t],
        vector [o, b, o, o, o, b, o, o, t, t, o, b, o, o, t],
        vector [o, o, b, o, o, o, t, o, t, t, o, o, b, t, t],
        vector [o, o, b, o, o, o, t, o, t, t, o, o, b, t, t],
    ];

    let height = terrains.length();
    let width = terrains[0].length();
    schema.map_config().set(map_config::new(width, height, terrains));
}
```

Note that deploy_hook.move will only run once per contract, so you will need to restart your pnpm run dev script to redeploy the contract.

Now letâ€™s render the terrain in the client via GameBoard.tsx.

## Turn boulders into obstructions
Although boulders are rendering on the map at this point, they do not yet prevent movement in the way we want them to. To accomplish this we will add an Obstruction schema and query for entities with that schema in our move method.

Let's start by adding the schema to the Dubhe config:
```ts filename="dubhe.config.ts" {15, 20} copy showLineNumbers
import { DubheConfig } from '@0xobelisk/sui-common';
export const dubheConfig = {
  name: 'monster_hunter',
  description: 'monster_hunter contract',
  data: {
    Direction: ['North', 'East', 'South', 'West'],
    TerrainType: ["None", "TallGrass", "Boulder"],
    Position: { x: 'u64', y: 'u64' },
  },
  schemas: {
    player: 'StorageMap<address, bool>',
    moveable: 'StorageMap<address, bool>',
    position: 'StorageMap<address, Position>',
    map_config: 'StorageValue<MapConfig>',
    obstruction: 'StorageMap<Position, bool>',
  },
  errors: {
    AlreadyRegistered: 'This address is already registered',
    CannotMove: 'This entity cannot move',
    SpaceObstructed: 'This space is obstructed',
  },
} as DubheConfig;
```

We'll then make sure deploy_hook.move initializes the boulders properly (with the obstruction and position component) so we can query them later.

```sui move filename="deploy_hook.move" {5, 31-41} copy showLineNumbers
module monster_hunter::deploy_hook;
use monster_hunter::schema::Schema;
use monster_hunter::terrain_type;
use monster_hunter::map_config;
use monster_hunter::position;

public entry fun run(schema: &mut Schema, _ctx: &mut TxContext) {
    let  o = terrain_type::new_none();
    let  t = terrain_type::new_tall_grass();
    let  b = terrain_type::new_boulder();
    let terrains = vector[
        vector [o, o, o, o, o, o, t, o, o, o, o, o, o, o, o],
        vector [o, o, t, o, o, o, o, o, t, o, o, o, o, b, o],
        vector [o, t, t, t, t, o, o, o, o, o, o, o, o, o, o],
        vector [o, o, t, t, t, t, o, o, o, o, b, o, o, o, o],
        vector [o, o, o, o, t, t, o, o, o, o, o, o, o, o, o],
        vector [o, o, o, b, b, o, o, o, o, o, o, o, o, o, o],
        vector [o, t, o, o, o, b, b, o, o, o, o, t, o, o, o],
        vector [o, o, t, t, o, o, o, o, o, t, o, b, o, o, t],
        vector [o, o, t, o, o, o, o, t, t, t, o, b, b, o, o],
        vector [o, o, o, o, o, o, o, t, t, t, o, b, t, o, t],
        vector [o, b, o, o, o, b, o, o, t, t, o, b, o, o, t],
        vector [o, o, b, o, o, o, t, o, t, t, o, o, b, t, t],
        vector [o, o, b, o, o, o, t, o, t, t, o, o, b, t, t],
    ];

    let height = terrains.length();
    let width = terrains[0].length();
    schema.map_config().set(map_config::new(width, height, terrains));

    let x: u64 = 0;
    let y: u64 = 0;
    y.range_do!(height, |y| {
        x.range_do!(width, |x| {
            let terrain = terrains[y][x];
            let position = position::new(x, y);
            if (terrain == terrain_type::new_boulder()) {
                schema.obstruction().set(position, true);
            }
        });
    });
}
```

Then let's use this schema in the move and register methods in map_system.move.
```sui move filename="map_system.move" {5, 10-11, 33-34} copy showLineNumbers
module monster_hunter::map_system;
use monster_hunter::schema::Schema;
use monster_hunter::position;
use monster_hunter::errors::already_registered_error;
use monster_hunter::errors::space_obstructed_error;

public fun register(schema: &mut Schema,  x: u64, y: u64, ctx: &mut TxContext) {
    let player = ctx.sender();
    already_registered_error(!schema.player().contains(player));
    let position = position::new(x, y);
    space_obstructed_error(!schema.obstruction().contains(position));

    schema.player().set(player, true);
    schema.moveable().set(player, true);
    schema.position().set(player, position);
}

public fun move_position(schema: &mut Schema, direction: Direction, ctx: &mut TxContext) {
    let player = ctx.sender();
    cannot_move_error(schema.moveable().contains[player]);

    let (mut x, mut y) = schema.position()[player].get();
    if (direction == direction::new_north()) {
        y = y - 1;
    } else if (direction == direction::new_east()) {
        x = x + 1;
    } else if (direction == direction::new_south()) {
        y = y + 1;
    } else if (direction == direction::new_west()) {
        x = x - 1;
    };

    let position = position::new(x, y);
    space_obstructed_error(!schema.obstruction().contains(position));

    schema.position().set(player, position);
}
```

## Wrap map boundary
Currently, players can move off of the bounds of the map. We'll address this by updating the spawn and move methods in map_system.move to wrap the player coordinate around the map size.
```sui move filename="map_system.move" {11-14, 40-43} copy showLineNumbers
module monster_hunter::map_system;
use monster_hunter::schema::Schema;
use monster_hunter::position;
use monster_hunter::errors::already_registered_error;
use monster_hunter::errors::space_obstructed_error;

public fun register(schema: &mut Schema,  x: u64, y: u64, ctx: &mut TxContext) {
    let player = ctx.sender();
    already_registered_error(!schema.player().contains(player));

    // Constrain position to map size, wrapping around if necessary
    let (width, height, _) = schema.map_config()[].get();
    let x = (x + width) % width;
    let y = (y + height) % height;

    let position = position::new(x, y);
    space_obstructed_error(!schema.obstruction().contains(position));


    schema.player().set(player, true);
    schema.moveable().set(player, true);
    schema.position().set(player, position);
}

public fun move_position(schema: &mut Schema, direction: Direction, ctx: &mut TxContext) {
    let player = ctx.sender();
    cannot_move_error(schema.moveable().contains[player]);

    let (mut x, mut y) = schema.position()[player].get();
    if (direction == direction::new_north()) {
        y = y - 1;
    } else if (direction == direction::new_east()) {
        x = x + 1;
    } else if (direction == direction::new_south()) {
        y = y + 1;
    } else if (direction == direction::new_west()) {
        x = x - 1;
    };

    // Constrain position to map size, wrapping around if necessary
    let (width, height, _) = schema.map_config()[].get();
    let x = (x + width) % width;
    let y = (y + height) % height;

    let position = position::new(x, y);
    space_obstructed_error(!schema.obstruction().contains(position));

    schema.position().set(player, position);
}