# Dubhe Engine Technical Whitepaper

## 1. Project Positioning and Vision

Dubhe Engine is an open-source, high-performance Move application engine developed by Obelisk Labs, designed to help developers build real-time, fully on-chain applications and verifiable game worlds. It positions itself as a "Move Application Creation Engine" and "Provable Game Engine," providing a complete toolchain to simplify on-chain development complexity. Through Dubhe, developers can rapidly build, deploy, and upgrade Move applications on underlying infrastructure like Sui, while maintaining Move's security and achieving high-performance on-chain computation.

Dubhe Engine aims to reduce the development complexity and cost of Move DApps, making the construction of fully on-chain, user-intent-centered worlds more efficient and feasible. Its vision is to become an important component of the Move ecosystem, driving the emergence of next-generation on-chain applications and games, and ultimately expanding the influence of the Move developer community.

As a comparison, Nervos CKB positions itself as a "Common Knowledge Base" for the crypto economy, focusing on state storage security and decentralization to serve Layer 2. Dubhe, however, focuses on the application layer, providing a unified development engine and toolset for multiple Move blockchains, implementing on-chain business logic in a developer-friendly manner. In other words, Dubhe Engine aims to make blockchain development experience close to traditional software development, lowering the entry barrier and enabling developers to focus more energy on innovation and business itself.

---

## 2. Core Technical Components and Their Functions

Dubhe Engine's architecture consists of two major parts: on-chain modules and off-chain tools, each containing several core components that collectively support fully on-chain applications:

### Harvard Architecture

Dubhe adopts the "Harvard architecture" design philosophy, completely separating contract logic from state data. On-chain, **System Modules** carry business logic while **Schema Modules** handle data storage, each serving their specific functions. This modular separation improves code maintainability and extensibility.

### Schema Data Storage

Schema is Dubhe's native on-chain structured storage abstraction, similar to Move's ORM layer. Developers use declarative Schema definitions instead of manually writing Move resource structures, with tools automatically generating corresponding storage contracts. Schema stores on-chain data in clear, intuitive structures and supports relational mapping for easy querying and management.

### System Contract Modules

System modules are Move contract logic written by developers, focusing on business implementation. They import libraries generated by Schema and call provided storage and event interfaces to implement specific application functions. For example, in gaming applications, system modules contain game rules and operational logic, while Schema stores game state (character attributes, items, etc.) for system modules to read and write.

### Move Execution Environment

All on-chain parts of Dubhe run on the underlying blockchain's Move virtual machine. For example, on the Sui network, Dubhe-generated contracts are executed as ordinary Move modules by Sui Move VM, enjoying Move language security checks (resource model, type safety, etc.) and underlying chain parallel execution optimizations. This ensures Dubhe contract logic complies with consensus and execution rules across all chains, maintaining security and consistency.

### Dubhe CLI Tools

Dubhe provides command-line toolchain covering the entire process from project initialization to deployment testing. Developers can create complete Dubhe project templates (including Move contracts and frontend frameworks) with a single command. CLI supports Schema code generation (`dubhe schemagen`), local network startup (`start:localnet`), and other functions, dramatically reducing project setup time (from days to hours). Additionally, CLI covers contract publishing, migration, and other operations, facilitating hot updates and data migration for contract logic.

### Dubhe Indexer

Indexer is Dubhe's real-time indexing solution for on-chain data. Currently on Sui, Dubhe Indexer synchronizes on-chain data to local SQLite databases, supporting complex Schema relationship indexing and real-time state update notifications. It adopts event-driven architecture to efficiently process blockchain events, providing high-performance query capabilities and ensuring timely access to on-chain data for applications (data availability). For real-time applications like games, Indexer enables frontends to quickly obtain on-chain state changes, improving user experience.

### Dubhe SDK Client Libraries

Dubhe provides type-safe client SDKs for multiple development languages (currently mainly TypeScript). The SDK encapsulates interfaces for interacting with on-chain contracts and local indexed data, allowing developers to conveniently call on-chain functions or query on-chain state in frontend applications. SDK automatically generates type definitions based on Schema, ensuring data structures and types obtained are consistent with on-chain, reducing tedious JSON parsing and assembly work. Through SDK, DApp frontends can read on-chain data (provided via Indexer) and send transactions to call system contracts, achieving complete frontend-backend interaction loops.

### Multi-chain Support Modules

Dubhe's design has multi-Move ecosystem compatibility capabilities. Architecturally, through modular encapsulation, specific implementation details for different chains are provided by respective packages. For example, Dubhe provides separate NPM packages for Sui, Aptos, Rooch, Initia, and other chains (such as `@0xobelisk/sui-cli`, `@0xobelisk/sui-indexer`, `@0xobelisk/aptos-client`, etc.), ensuring consistent development experience across different chain environments. This vendor-lock-free multi-chain support allows developers' Move applications to deploy and run on any Move-supporting chain, maximizing code and design reuse.

The above components work together to form Dubhe Engine's complete development stack. Overall, Dubhe provides developers with a one-stop solution from on-chain contract frameworks to off-chain toolchains, making building composable, scalable on-chain applications simpler and more efficient.

---

## 3. Dubhe Engine Execution Model (VM, State Transitions, Transaction Processing)

Dubhe Engine's execution model is built on Move smart contract programming paradigms and underlying chain transaction processing mechanisms, but introduces a unique Schema-System separation pattern to optimize state management and logic execution.

### Move VM and Transaction Execution

At runtime, whenever user transactions (such as operations in DApps) are submitted to the blockchain, the underlying chain's consensus arranges Move VM to execute corresponding contract functions. For Dubhe-developed applications, these transactions mostly call system module functions generated by Dubhe or written by developers. Move VM reads corresponding Schema-stored data according to on-chain state, applies business logic from system modules, changes necessary state and generates events, and finally atomically commits these changes in the transaction. The entire process follows Move language security rules, such as resources not being illegally copied or lost, transactions either fully succeeding or rolling back, ensuring correctness and atomicity of on-chain state transitions.

### Data Schema and State Transitions

Dubhe introduces Schema as state storage units, dramatically changing traditional Move contract state management methods. Developers define data structures (Schema) in declarative syntax in project configuration, including fields, events, and error types. By running the `schema:gen` command, Dubhe CLI reads these definitions and automatically generates corresponding Move modules, implementing these Schema storage logic on-chain. Generated Schema modules utilize Move's dynamic fields mechanism at the bottom layer, allowing contracts to flexibly add or modify storage fields without changing existing storage structures. This mechanism is similar to maintaining an extensible key-value store on-chain, decomposing complex data objects into manageable units at the bottom layer. Therefore, when a transaction triggers state transitions, system module logic calls APIs provided by Schema modules to complete on-chain data reads and writes, ensuring data structure consistency and integrity.

### Logic and Data Decoupling Execution Flow

In Dubhe Engine, business logic execution is completed by system modules, while state reads and writes are performed through Schema modules. This decoupling allows developers to independently evolve logic and data structures: when Schema structures need expansion or modification, old data can be migrated to new Schema through migration scripts (such as `migrate.move`) and hot upgrade mechanisms provided by Dubhe; business logic changes can also be implemented by publishing new system module versions without affecting underlying storage layouts. During execution, system modules cooperate closely with Schema modules. For example, when system logic needs to create a new object instance, it actually calls Schema modules to create that object in on-chain resource storage and assign a unique key; when system logic queries or modifies attributes, it also accesses or updates corresponding fields through functions provided by Schema. This pattern can be compared to Entity-Component-System (ECS): Schema defines components (data), system modules play systems (logic), and certain on-chain object IDs are similar to entities, mounting different components to entities through dynamic fields. The result is higher modularity and upgradeability of on-chain state models while ensuring performance, similar to upgrading from manual low-level storage management to using high-level database ORM development experience.

### Events and Transaction Processing

Dubhe-generated Schema modules also automatically generate corresponding event types for each data structure. System modules can trigger these events during transaction execution to record important state changes. These events are recorded in block logs by the underlying chain. On one hand, events improve transparency of on-chain state transitions, enabling offline analysis or indexing tools to capture key changes; on the other hand, components like Dubhe Indexer subscribe to on-chain event streams, implementing event-driven state synchronization. Therefore, whenever transaction processing is completed (confirmed through consensus), associated state modifications and events can be quickly reflected in off-chain data views through Indexer, providing near real-time state updates for frontends and developers.

In summary, Dubhe Engine's execution model innovates on-chain state management through Schema/System layering and dynamic fields while following underlying chain Move VM transaction processing flows. This brings clearer contract structures, more convenient state expansion, and stronger support for complex on-chain applications (such as game worlds). Developers no longer need to worry about tedious low-level storage layouts and can focus on writing high-level business logic, as Dubhe has already built robust infrastructure for state transitions and data management at the engine layer.

---

## 4. Consensus and Data Availability

### Consensus Mechanism

Dubhe Engine itself is not an independent blockchain, so it does not introduce new consensus algorithms. Applications it builds ultimately deploy and run on existing infrastructure chains, such as Sui, Aptos, etc. This means transaction confirmation and on-chain state reliability of Dubhe DApps completely rely on the consensus mechanisms and security of corresponding underlying chains. Taking Sui as an example, it uses Narwhal/Bullshark consensus (a high-performance Byzantine fault-tolerant protocol) to order and confirm transactions; Dubhe applications on Sui also go through this consensus process to reach final state. Once transactions are confirmed by underlying chain consensus, Dubhe's on-chain module execution results are considered immutable on-chain facts. For developers, there's no need to concern themselves with consensus implementation details to trust that Dubhe application states have the same security and consistency as other applications on the underlying chain.

### Data Availability

Because application states are stored on underlying blockchains, Dubhe inherits underlying chain data availability guarantees—all blocks and state data submitted on-chain are propagated in the chain's peer-to-peer network and stored by full nodes, ensuring anyone can access and verify this data in the future. Based on this, Dubhe further enhances data accessibility for developers through built-in indexers. Dubhe Indexer directly connects to blockchain nodes or full node RPC interfaces, monitors new blocks and events, extracts and stores Dubhe application-related data in developer-owned databases. This off-chain replica ensures applications don't need to rely on on-chain nodes every time when reading historical states or complex queries, improving query efficiency and reliability. When blockchains experience temporary network partitions or node desynchronization, local data replicas maintained by Dubhe Indexer can also provide cache support to some extent, ensuring smooth operation of application frontends.

Worth mentioning, Dubhe Indexer adopts real-time event-driven architecture, capable of immediately pushing changes when on-chain data updates. This is crucial for building real-time interactive on-chain games or applications: after users trigger transactions in DApps, not only do they get confirmation through underlying chain consensus, but Indexer immediately provides new states to the application layer, achieving real-time synchronization of frontend interface states. Therefore, from application developer and user perspectives, Dubhe not only utilizes underlying chain consensus to guarantee data reliability and availability but also makes data usable through its own indexing mechanism—always available for efficient querying and response. This is also one of Dubhe Engine's important characteristics for real-time on-chain applications.

---

## 5. Network Layer Design and P2P Protocols

Dubhe Engine has not introduced custom peer-to-peer network protocols; its network layer design mainly relies on underlying blockchain P2P networks to implement application transaction propagation and state synchronization. In Sui networks, each Dubhe transaction is broadcast through Sui's node network, ordered by validator nodes through consensus, and packaged into blocks; blocks then spread and store across the entire network through Sui P2P networks. Dubhe application data therefore enjoys the same guarantees as other contract data from underlying network layers. The situation is similar on Aptos and other Move chains—Dubhe contracts do not change chain network mechanisms.

Although Dubhe itself doesn't have independent network protocols, it provides convenient network environment support for development and testing. For example, Dubhe CLI can start local test network environments with one click (such as running a local Sui node), allowing developers to debug contracts without connecting to public testnets. This Sandbox network functionality allows developers to locally simulate blockchain block production and transaction execution, combined with Dubhe's indexing and frontend tools, achieving completely offline development loops. P2P communication in sandbox networks is usually simplified to local inter-process communication or local area network communication, but remains transparent to upper-layer applications, making it convenient for developers to conduct multi-node, multi-user interaction testing.

Additionally, Dubhe Engine's emphasized real-time event characteristics also involve network communication: Dubhe Indexer needs to subscribe to blockchain event streams from nodes. In Sui, this might be through WebSocket or proprietary subscription protocols to obtain new blocks and events; in Aptos through REST or exponential synchronization queries. Dubhe encapsulates these details, enabling Indexer to smoothly access different chain node networks and monitor Dubhe contract-related data changes. Overall, Dubhe hasn't reinvented the wheel by defining new P2P protocols but fully utilizes existing network layers of mainstream chains. For application developers, this is an advantage: no need to worry about underlying network details, as Dubhe has already established data pathways from on-chain to off-chain, ensuring reliable and efficient network communication.

---

## 6. Development Interfaces and Extensibility

### Development Interfaces

Dubhe Engine provides rich and developer-friendly interfaces covering all aspects from contract development to frontend integration. First is the command-line interface (CLI), which serves as the development entry point. Through simple commands like `pnpm create dubhe`, developers can interactively initialize new Dubhe project templates. CLI guides selection of target blockchains (such as Sui, Aptos), project names, and template types, automatically generating complete projects containing Move contract and frontend code architecture. This process greatly simplifies traditional steps that required separately initializing contract repositories and frontend repositories. Meanwhile, Dubhe CLI also has built-in build, publish, and test commands. For example, running `pnpm run schema:gen` calls Dubhe Schema code generation tools, automatically producing Move module code based on developer-defined configurations; running `pnpm run start:localnet` can start local chains for debugging, while `pnpm run dev` can simultaneously start frontend development servers, enabling frontend-backend collaborative debugging. Overall, CLI greatly improves development experience, allowing developers to start coding work "out of the box" while automating tedious scaffolding and configuration tasks.

After contract development is complete, Dubhe's frontend SDK becomes a key part of application interfaces. Taking TypeScript SDK as an example, developers can install corresponding chain SDK packages like `@0xobelisk/sui-client` in Node.js or browser environments. The SDK provides high-level APIs, such as directly calling Dubhe system contract methods (implemented through sending transactions at the bottom layer), or querying current states of certain Schema objects on-chain (implemented through Indexer querying local databases at the bottom layer). Since Schema provides clear structures for data, SDK can parse on-chain returned data into strongly-typed objects. For example, if developers define a Schema named Counter (containing a value field), SDK returns an object with a value property when querying, rather than just obscure bytes or generic JSON. This enables frontend code to operate on-chain data naturally, reducing errors. At the same time, Dubhe SDK also handles detail differences with underlying chain APIs, obtaining data through RPC or subscriptions on Sui, possibly through different interfaces on Aptos, but presenting unified calling forms to developers.

### Extensibility

Dubhe Engine architecturally emphasizes extension and upgrade capabilities, reflected at multiple levels:

**For applications themselves**, Dubhe provides comprehensive upgrade paths. Through Schema + system module patterns, developers can extend storage structures or adjust logic when needed, implementing iterative contract updates. Dubhe CLI-generated projects contain exemplary migration scripts (such as `migrate.move`), helping developers smoothly migrate old data when deploying new contract versions, ensuring no state loss or consistency breaking during upgrades. Additionally, Dubhe engine also supports "Hot Updates" concepts, minimizing impact on running applications during upgrade deployments, reducing downtime. This series of mechanisms provides sustainable evolution guarantees for long-term operating on-chain applications.

**For different blockchain environments**, Dubhe's modular design makes it easy to support new Move platforms. This means if new public chains adopting Move VM appear, or enterprise private chains, Dubhe only needs to develop corresponding adapter packages (implementing CLI commands, deployment, indexing, etc., integration) to include them in supported ranges. Currently Dubhe-adapted chains include Sui, Aptos, Rooch, Initia, etc. Due to clear abstraction levels, the cost of adding new chains is very low, truly achieving "learn once, use on multiple chains." Developers won't be locked into single platforms and can choose the most suitable chains for deployment based on project needs while enjoying the same Dubhe development experience.

**For engine functionality**, Dubhe has a roadmap for plugin-based and continuous improvement. The official roadmap has planned multiple extension function modules, such as zero-knowledge login plugins (allowing users to verify identity with zero-knowledge proofs) and transaction fee delegation plugins (applications paying Gas for users, improving user experience). After these features are integrated through plugin forms, they will further enrich Dubhe engine capabilities without breaking existing architecture stability. Additionally, state synchronization client hooks are in development, which will enable frontend clients to directly synchronize on-chain state updates, building truly real-time dynamic application interfaces. There are also planned custom runtime sandboxes and world browser interfaces, respectively for providing more flexible local debugging runtimes and intuitively visualizing on-chain world data browsing. These extended functions show Dubhe Engine has good extensibility, continuously meeting more advanced application needs through module plugins and toolchain upgrades.

**For developer ecosystem**, Dubhe adopts open co-construction models. Its code is open source and welcomes community contributions, supplemented by detailed documentation and example projects. Developers can also perform secondary development on the engine based on their project needs, such as extending CLI commands, customizing Index data processing logic, etc. The Dubhe team encourages more peripheral tools and libraries to emerge on its framework, jointly building a prosperous Move application ecosystem. This openness further ensures Dubhe's vitality, enabling it to evolve with community needs and become trusted infrastructure for developers.

In summary, Dubhe Engine pursues ease of use and consistency in development interfaces while emphasizing modularity and forward-thinking in system extension. Whether it's extension within single application lifecycles or engine adaptation to more scenarios, Dubhe has made full design considerations, demonstrating future-oriented architectural thinking.

---

## 7. Comparison with Existing Mainstream Chains

Although Dubhe Engine itself is not an independent blockchain, its concepts and implementations can be compared with existing blockchain development modes to highlight its characteristics:

**Compared to direct Move chain development** (such as directly writing contracts on Sui/Aptos): Traditional approaches require developers to manually write Move modules defining resource types, storage fields, events, and even error codes, and handle their on-chain read and update logic. This is not only tedious but can also lead to hard-to-track state errors if not careful. Dubhe provides higher-level abstractions through Schema—developers declare data structures, and the engine automatically generates storage and event code. This "what you see is what you get" approach is like replacing low-level database table operations with high-level ORM usage, greatly improving development efficiency and correctness. Meanwhile, for index queries, developers usually need to build services scanning on-chain events or utilize third-party indexers (such as Sui Indexer) to query complex data in frontends; Dubhe has built-in automatic Indexer, providing structured on-chain data without additional work. In summary, Dubhe greatly lowers Move DApp development barriers, allowing developers to focus on business logic while reducing energy investment in on-chain storage management and data indexing.

**Compared to Ethereum and other EVM public chain development**: When developing smart contracts on Ethereum (Solidity, etc.), data storage and logic are usually mixed in contracts, lacking data layer abstractions like Dubhe. Additionally, EVM contract data reading depends on node RPC interfaces, and complex queries often require external indexing solutions like The Graph. In comparison, Dubhe based on Move provides stricter security models (resources cannot be arbitrarily copied, effectively avoiding common vulnerabilities) and built-in indexing solutions. Developers in Dubhe can clearly define state models through Schema, somewhat similar to simultaneously writing contracts and configuring subgraphs on Ethereum, but Dubhe packages both in a unified framework, providing smoother and more consistent development experience. Additionally, regarding upgradeability, Ethereum contracts need complex patterns like proxy contracts to upgrade logic, while Dubhe utilizes Move's module redeployability characteristics and migration scripts, making upgrade processes more intuitive.

**Compared to Polkadot parachain development**: Polkadot provides a framework for building independent blockchains (Substrate), where developers can customize blockchain logic at all layers, including consensus, storage, Runtime, etc., to run under Polkadot shared security. In comparison, Dubhe doesn't require developers to build new blockchains but builds applications on existing public chains. This means developers don't need to worry about consensus algorithms or network topology, only focusing on application logic itself. Polkadot emphasizes multi-chain parallelism and cross-chain communication, while Dubhe emphasizes reusing application frameworks across multiple chains. For example, if a team wants to deploy similar functionality games on several Move chains, Dubhe provides unified development frameworks to deploy instances on different chains without needing to develop separate versions for each chain from scratch. This reflects differences in their expansion routes: Polkadot improves overall throughput through horizontal scaling (multi-chain parallelism), while Dubhe reduces multi-chain deployment costs through tool reuse. For application scenarios, for most DApps that don't need custom underlying chain rules, Dubhe's approach is obviously more lightweight and faster.

**Compared to other on-chain game engines/frameworks**: In blockchain gaming, there are also some chain-specific frameworks, such as MUD game engine on Ethereum (based on ECS concepts). Compared to these solutions, Dubhe's biggest difference is supporting full on-chain state and multi-chain universality. Traditional game engines (Unity, Unreal, etc.) focus on client presentation and offline simulation, while Dubhe focuses on putting game rules and states on-chain for execution, ensuring verifiability and immutability. While engines like MUD also attempt full on-chain state, they're usually bound to Ethereum ecosystem, while Dubhe embraces Move ecosystem, going further in both performance and security models. Additionally, Dubhe is suitable not only for games but also for any applications requiring trusted backends (DeFi, social, etc.), with stronger universality. It can be considered that Dubhe introduces some best practices from modern software engineering (layered architecture, ORM, modularity) into on-chain development, creating a cross-chain applicable full-stack solution that stands out among current mainstream chain development options.

Overall, Dubhe Engine's development paradigm has significant advantages over mainstream blockchain development modes in simplifying on-chain programming, strengthening state management, and supporting multi-chain deployment. It doesn't replace underlying public chain functionality but exists as an upper-layer "application engine," encapsulating heavy infrastructure work to enable developers of different backgrounds to more easily build serious on-chain applications. This has pioneering significance in current blockchain technology stacks.

---

## 8. Module Structure and System Architecture

### Architecture Overview

Dubhe Engine's system architecture can be divided into on-chain and off-chain levels working collaboratively. The on-chain part consists of Dubhe auto-generated and developer-written Move contract modules, deployed on target blockchains and executed by chain nodes. The off-chain part is a series of supporting tools and services helping developers develop, monitor, and interact with on-chain applications.

### On-chain Structure

The on-chain part structure includes:

**Underlying Blockchain** (such as Sui/Aptos): Provides runtime environment (Move VM), consensus, and storage. It's the system foundation, ensuring transaction processing and data persistence.

**Dubhe Contract Framework**: Contract collections deployed on blockchain, including Schema modules and System modules. Schema modules act as on-chain "database layers," encapsulating storage operations; System modules implement specific business logic. Both cooperate closely through Move native calling mechanisms: System modules call functions provided by Schema to read/write state, Schema triggers events for System modules or off-chain subscriptions.

**On-chain Data and Events**: Dubhe applications generate data changes and event logs on blockchain during execution. All states are stored in persistent storage spaces of on-chain accounts (such as Sui Objects), while events propagate with blockchain logs for offline component use.

### Off-chain Support Environment

The off-chain part constitutes development and runtime support environment:

**Dubhe CLI & Local Nodes**: Developers use CLI to interact with the engine, such as initializing projects, compiling and publishing contracts, running tests. CLI can start local node/network to simulate blockchain for offline contract logic debugging. Local networks essentially run underlying chain software (such as Sui local network nodes), thus having similar P2P communication and consensus processes as mainnet, but limited to development machines or local area networks.

**Dubhe Indexer Service**: Off-chain indexing processes deployed, connecting to blockchain nodes (local or remote) to obtain Dubhe contract-related events and state changes. Indexer writes this data to local databases (currently usually SQLite or similar embedded DB), organizing data table structures according to Schema definitions. Indexer runs continuously, maintaining synchronization between on-chain state and database, providing query interfaces. For applications with high real-time requirements, Indexer can also push update notifications to frontends through mechanisms like WebSocket.

**Dubhe Frontend SDK**: As off-chain interface layer for frontend applications (web, mobile), SDK internally calls APIs provided by Indexer to query on-chain state and submits transactions through blockchain node RPC to call on-chain System module functions. SDK hides network communication details from developers; whether on-chain data comes from local Indexer or remote nodes, calling methods remain consistent. Additionally, SDK ensures data type safety, mapping complex on-chain data structures to easy-to-use objects.

**Frontend Applications**: Finally, user interfaces built by developers (such as web DApps or game clients) interact with on-chain through Dubhe SDK. Users trigger operations in frontends, converted to on-chain transactions via SDK, processed by underlying blockchain and updating state; updated states are captured by Indexer for frontend querying or receiving notifications. The entire process forms a closed loop, making user operations → on-chain state changes → frontend feedback seamlessly connected, ensuring user-seen worlds stay synchronized with on-chain real state.

### Architecture Characteristics

Dubhe's module structure demonstrates high cohesion and layering: on-chain modules focus on securely storing and changing state, while off-chain modules optimize around developer experience and performance. This layered architecture resembles classic three-tier architecture (blockchain as database layer, Dubhe contracts as business layer, frontend + SDK as presentation layer), while incorporating blockchain-specific publish/subscribe models (event-driven) and decentralized trust models.

Through clear module boundaries, Dubhe Engine achieves easily maintainable code structure and clear data flow. When application scale expands or requirements change, modules can extend and upgrade relatively independently, such as adding more indexing dimensions, replacing frontend display methods, or adjusting contract logic, while other layers need minimal changes. This ensures Dubhe Engine architecture's adaptability to complex application scenarios.

In summary, Dubhe Engine organically combines excellent traditional software engineering practices with blockchain decentralization characteristics, forming a unique system architecture. For technical developers, this architecture provides both familiar development paradigms (such as layering, ORM, real-time push) while fully utilizing blockchain underlying capabilities (consensus, security, immutability), enabling developers to more confidently build next-generation on-chain application worlds.

---

_This technical whitepaper provides a comprehensive overview of Dubhe Engine's architecture, capabilities, and positioning within the Move ecosystem. For the latest updates and detailed implementation guides, please refer to the official Dubhe documentation._
